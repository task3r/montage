#ifndef YCSB_HPP
#define YCSB_HPP

/*
 * This is a test with fixed number of operations for mappings. 
 * The workload is traces generated by YCSB.
 * You can generate your own traces using our fork of YCSB, 
 * accessible at https://github.com/urcs-sync/YCSB-tracing
 */

#include "TestConfig.hpp"
#include "RMap.hpp"
#include <string>
#include <vector>
#include <fstream>
#include <sstream>
#include <thread>
#include <iostream>
#include <limits>
#include <cstdlib>
#include <random>

using namespace std;
class YCSBTest : public Test{
public:
    // const std::string YCSB_PREFIX = "/localdisk2/ycsb_traces/ycsb/";
    RMap<std::string,std::string>* m;
    vector<std::string>** traces;
    std::string trace_prefix;
    std::string thd_num;
    size_t val_size = 1024;
    std::string value_buffer;
    YCSBTest(const std::string& YCSB_PREFIX){
        //sz is 100k or 1m, wl is a or b
        trace_prefix = YCSB_PREFIX + "-";
    }

    void getRideable(GlobalTestConfig* gtc){
        Rideable* ptr = gtc->allocRideable();
        m = dynamic_cast<RMap<std::string, std::string>*>(ptr);
        if (!m) {
             errexit("YCSBTest must be run on RMap<std::string,std::string> type object.");
        }
    }
    void parInit(GlobalTestConfig* gtc, LocalTestConfig* ltc){
        m->init_thread(gtc, ltc);
    }
    void init(GlobalTestConfig* gtc){

        if(gtc->checkEnv("ValueSize")){
            val_size = atoi((gtc->getEnv("ValueSize")).c_str());
        }
        value_buffer.reserve(val_size);
        value_buffer.clear();
        std::mt19937_64 gen_v(7);
        for (size_t i = 0; i < val_size - 1; i++) {
            value_buffer += (char)((i % 2 == 0 ? 'A' : 'a') + (gen_v() % 26));
        }
        value_buffer += '\0';
        getRideable(gtc);

        thd_num = to_string(gtc->task_num);
        std::string load_prefix = trace_prefix + "load-" + thd_num + ".";
        if(gtc->verbose){
            cout<<"YCSB trace prefixed "<<trace_prefix<<endl;
        }

        /* do prefilling */
        thread** thds = new thread* [gtc->task_num];
        for(int i=0; i<gtc->task_num; i++){
            // thds[i] = new thread (&YCSBTest::doPrefill, this, load_prefix+to_string(i), i);
            YCSBTest::doPrefill(load_prefix+to_string(i), 0);
        }
        // for(int i=0; i<gtc->task_num; i++){
            // thds[i]->join();
        // }
        if(gtc->verbose){
            printf("Prefilled!\n");
        }

        /* get workload */
        traces = new vector<std::string>* [gtc->task_num];
        std::string run_prefix = trace_prefix + "run-" + thd_num + ".";
        for(int i=0;i<gtc->task_num;i++){
            traces[i] = new vector<std::string>();
            std::ifstream infile(run_prefix+to_string(i));
            std::string cmd;
            while(getline(infile, cmd)){
                traces[i]->push_back(cmd);
            }
        }

        /* set interval to inf so this won't be killed by timeout */
        gtc->interval = numeric_limits<double>::max();
    }
    void operation(const std::string& t, int tid, bool rm = false){
        string tag = t.substr(0, 3);
        if (tag == "Add" || tag == "Upd") {
            if (tag == "Add"){
                m->insert(t.substr(4), value_buffer, tid);
            } else {// Update
                if(rm)
                    m->remove(t.substr(7), tid);
                else
                    m->insert(t.substr(7), value_buffer, tid);
            }
        }
        else if (tag == "Rea") {
            auto ret = m->get(t.substr(5), tid);
            static std::string val __attribute__((used)) = ret.value_or("");
        } else {
            assert(0&&"invalid operation!");
        }
    }
    void doPrefill(std::string infile_name, int tid){
        std::ifstream infile(infile_name);
        std::string cmd;
        // pds::init_thread(tid);

        while(getline(infile, cmd)){
            operation(cmd, tid);
        }
        infile.close();
    }

    int execute(GlobalTestConfig* gtc, LocalTestConfig* ltc){
        int tid = ltc->tid;
        int ops = 0;
        std::mt19937_64 gen_v(ltc->tid);
        
        for (size_t i = 0; i < traces[tid]->size(); i++) {
            operation(traces[tid]->at(i), tid, gen_v()&true);
            ops++;
        }
        return ops;
    }
    void cleanup(GlobalTestConfig* gtc){
        delete m;
        for(int i=0;i<gtc->task_num;i++){
            delete traces[i];
        }
        delete traces;
    }
};

#endif
